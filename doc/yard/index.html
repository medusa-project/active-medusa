<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>
  File: README
  
    &mdash; ActiveMedusa
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!file.README.html";
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'>
<h1 id="label-ActiveMedusa">ActiveMedusa</h1>

<p>ActiveMedusa provides a simple ActiveRecord-like interface to a Fedora 4
repository, using Solr for lookup and querying.</p>
<ul><li>
<p><strong><a href="https://github.com/medusa-project/active-medusa">GitHub
home</a></strong></p>
</li><li>
<p><strong><a
href="http://medusa-project.github.io/active-medusa/frames.html">API
documentation</a></strong></p>
</li></ul>

<h1 id="label-Features">Features</h1>
<ul><li>
<p>ActiveRecord-like syntax for CRUD and querying.</p>
</li><li>
<p>Basic and somewhat customizable RDF ontology. Create your own RDF
predicates  or use existing ones.</p>
</li><li>
<p>Customizable Solr schema. Although some extra fields are required, their 
names are up to you.</p>
</li><li>
<p>Supports binary and container nodes, both of which are first-class,
queryable  entities.</p>
</li><li>
<p>Direct read/write access to entities&#39; RDF graphs.</p>
</li><li>
<p>Supports ‚Äúbelongs-to‚Äù and ‚Äúhas-many‚Äù relationships between entities.</p>
</li><li>
<p>No-configuration support for node hierarchy traversal via automatic
<code>parent</code>  and <code>children</code> methods on entities.</p>
</li></ul>

<h1 id="label-Limitations">Limitations</h1>
<ul><li>
<p>No cascading</p>
</li><li>
<p>No uniquing</p>
</li><li>
<p>Can only set references on the owned side</p>
</li><li>
<p>Probably a lot more</p>
</li></ul>

<h1 id="label-Installation">Installation</h1>

<p>Currently ActiveMedusa is not available via rubygems. There are a couple of
other options:</p>

<h2 id="label-Refer+to+a+local+copy">Refer to a local copy</h2>

<p>Check out the code from GitHub and point to it in your application&#39;s
Gemfile:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>path:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>/path/to/active_medusa</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<h2 id="label-Refer+to+a+copy+on+GitHub">Refer to a copy on GitHub</h2>

<p>Add one of these lines to your application&#39;s Gemfile, depending on what
you&#39;d like to work with:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># bleeding-edge
</span><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>github:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>medusa-project/active-medusa</span><span class='tstring_end'>&#39;</span></span>
<span class='comment'># the latest release
</span><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>github:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>medusa-project/active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>branch:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>master</span><span class='tstring_end'>&#39;</span></span>
<span class='comment'># a particular release
</span><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>github:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>medusa-project/active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>tag:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>1.0.0</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>Then execute:</p>

<pre class="code ruby"><code class="ruby">$ bundle</code></pre>

<h1 id="label-Usage">Usage</h1>

<h2 id="label-Initializing">Initializing</h2>

<p>ActiveMedusa needs to know some stuff about your setup. You can tell it
like this. Documentation of each option is available <a
href="http://medusa-project.github.io/active-medusa/ActiveMedusa/Configuration.html">here</a>.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Configuration</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_config'>config</span><span class='op'>|</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_fedora_url'>fedora_url</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://localhost:8080/fcrepo/rest</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_logger'>logger</span> <span class='op'>=</span> <span class='const'>Rails</span><span class='period'>.</span><span class='id identifier rubyid_logger'>logger</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_class_predicate'>class_predicate</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/hasClass</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_url'>solr_url</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://localhost:8983/solr</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_core'>solr_core</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>collection1</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_more_like_this_endpoint'>solr_more_like_this_endpoint</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>/mlt</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_uri_field'>solr_uri_field</span> <span class='op'>=</span> <span class='symbol'>:id</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_class_field'>solr_class_field</span> <span class='op'>=</span> <span class='symbol'>:class_s</span> <span class='comment'># used by ActiveMedusa finder methods
</span>  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_uuid_field'>solr_uuid_field</span> <span class='op'>=</span> <span class='symbol'>:uuid_s</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_default_search_field'>solr_default_search_field</span> <span class='op'>=</span> <span class='symbol'>:searchall_txt</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_facet_fields'>solr_facet_fields</span> <span class='op'>=</span> <span class='lbracket'>[</span><span class='symbol'>:collection_facet</span><span class='comma'>,</span> <span class='symbol'>:creator_facet</span><span class='comma'>,</span>
                              <span class='symbol'>:date_facet</span><span class='comma'>,</span> <span class='symbol'>:format_facet</span><span class='comma'>,</span> <span class='symbol'>:language_facet</span><span class='rbracket'>]</span>
<span class='kw'>end</span>
</code></pre>

<p>(If you are using Rails, you would put this in
<code>config/initializers/active_medusa.rb</code>, and then restart your
application.)</p>

<h3 id="label-Configuring+a+Solr+update+strategy">Configuring a Solr update strategy</h3>

<p>ActiveMedusa does not write to Solr; you must devise a way to maintain your
Solr index without ActiveMedusa&#39;s help. One option would be to use a
strategy like <a
href="https://github.com/fcrepo4/fcrepo-message-consumer">fcrepo-message-consumer</a>
(deprecated) or <a
href="https://github.com/fcrepo4/fcrepo-camel">fcrepo-camel</a> which keep
Solr updated by listening for changes in your repository. Another option
would be to populate Solr from your application, such as by using
<code>after_save</code> callbacks on your ActiveMedusa models.</p>

<p>Getting this working is beyond the scope of ActiveMedusa; but keep in mind
that any Solr fields referred to in your
<code>ActiveMedusa::Configuration</code> object, as well as any referred to
in your entities (see below), need to exist in Solr and get populated some
way or other. In the example above, <code>searchall_txt</code> is
presumably a dynamic <code>copyField</code> that Solr will populate itself,
and likewise the <code>*_facet</code> fields; but all of the rest need to
exist, either as regular or dynamic fields.</p>

<h2 id="label-Defining+Entities">Defining Entities</h2>

<p>Here we will declare some entity/model classes that will be used throughout
this readme. <code>Collection</code> and <code>Item</code> will correspond
to Fedora container nodes, and <code>Bytestream</code> will correspond to
Fedora binary nodes. These are all common entities found in many
repositories, but you could change the nomenclature, or add other entities.
Note that <code>Collection</code> and <code>Item</code> inherit from
<code>ActiveMedusa::Container</code> while <code>Bytestream</code> inherits
from <code>ActiveMedusa::Binary</code>. These are the two base classes from
which all of your entities must inherit.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># collection.rb
</span><span class='kw'>class</span> <span class='const'>Collection</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span>
  <span class='id identifier rubyid_entity_class_uri'>entity_class_uri</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/Collection</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbol'>:items</span>
  <span class='id identifier rubyid_property'>property</span> <span class='symbol'>:title</span><span class='comma'>,</span>
           <span class='label'>type:</span> <span class='symbol'>:string</span><span class='comma'>,</span>
           <span class='label'>rdf_predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://purl.org/dc/elements/1.1/title</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
           <span class='label'>solr_field:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>title_s</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>

<span class='comment'># item.rb
</span><span class='kw'>class</span> <span class='const'>Item</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span>
  <span class='id identifier rubyid_entity_class_uri'>entity_class_uri</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/Item</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbol'>:items</span>
  <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbol'>:bytestreams</span>
  <span class='id identifier rubyid_belongs_to'>belongs_to</span> <span class='symbol'>:collection</span><span class='comma'>,</span> <span class='label'>predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/isMemberOf</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
             <span class='label'>solr_field:</span> <span class='symbol'>:collection_s</span>
  <span class='id identifier rubyid_belongs_to'>belongs_to</span> <span class='symbol'>:item</span><span class='comma'>,</span> <span class='label'>predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/isChildOf</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
             <span class='label'>solr_field:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>parent_s</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>parent</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_property'>property</span> <span class='symbol'>:full_text</span><span class='comma'>,</span>
           <span class='label'>type:</span> <span class='symbol'>:string</span><span class='comma'>,</span>
           <span class='label'>rdf_predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/fullText</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
           <span class='label'>solr_field:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>full_text_txt</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>

<span class='comment'># bytestream.rb
</span><span class='kw'>class</span> <span class='const'>Bytestream</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Binary</span>
  <span class='id identifier rubyid_entity_class_uri'>entity_class_uri</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/Bytestream</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_belongs_to'>belongs_to</span> <span class='symbol'>:item</span><span class='comma'>,</span> <span class='label'>predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/isOwnedBy</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
</code></pre>

<h3 id="label-Defining+Classes">Defining Classes</h3>

<p>Every entity needs to have a URI designating its class. This can be
specified with the <code>entity_class_uri</code> method. The value you
define will be used as the object of a triple whose predicate is the value
of <code>ActiveMedusa::Configuration.class_predicate</code>.</p>

<h3 id="label-Defining+Properties">Defining Properties</h3>

<p><code>property</code> is a convenience method that maps entity properties
to an instance&#39;s RDF graph and creates accessor and finder methods for
them. It also enables bonus features like validation,
<code>find_by_x</code>, auto-generated accessors, and ability to use the
properties in <code>create</code> and <code>update</code> calls.</p>

<p><code>property</code> predicates must be unique and can only be used in one
triple per entity graph.</p>

<p>You do not need to define all, or any, of an entity&#39;s properties with
<code>property</code>. If you prefer, you can manually mutate an
instance&#39;s <code>RDF::Graph</code> instance, accessible via
<code>rdf_graph</code>. But in that case, you wouldn&#39;t get the bonus
features.</p>

<h3 id="label-Defining+Relationships">Defining Relationships</h3>

<p>Using the <code>has_many</code> and <code>belongs_to</code> methods, the
example above specifies that collections can contain zero or more items;
items can contain zero or more bytestreams; and items can also contain zero
or more items (as in aggregations, a.k.a. compound objects). Note that both
sides of the relationship must be specified, so for every
<code>has_many</code> on an owning entity, there must be a
<code>belongs_to</code> on the owned entity. The <code>belongs_to</code>
side also requires a <code>:predicate</code> option that specifies what RDF
predicate to use to store the relationship in Fedora.</p>

<p><em>Note: If any of your entity classes reside in a namespace, you will
need to add a <code>class_name</code> option to your relationship
definitions:</em></p>

<pre class="code ruby"><code class="ruby"><span class='comment'># collection.rb
</span><span class='kw'>module</span> <span class='const'>Entities</span>
  <span class='kw'>class</span> <span class='const'>Collection</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span>
    <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbol'>:items</span><span class='comma'>,</span> <span class='label'>class_name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Entities::Item</span><span class='tstring_end'>&#39;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='comment'># item.rb
</span><span class='kw'>module</span> <span class='const'>Entities</span>
  <span class='kw'>class</span> <span class='const'>Item</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span>
    <span class='id identifier rubyid_belongs_to'>belongs_to</span> <span class='symbol'>:collection</span><span class='comma'>,</span> <span class='label'>predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/isMemberOf</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
               <span class='label'>solr_field:</span> <span class='symbol'>:collection_s</span><span class='comma'>,</span> <span class='label'>class_name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Entities::Collection</span><span class='tstring_end'>&#39;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h2 id="label-Creating+Entities">Creating Entities</h2>

<p><code>Item.new</code> will create an <code>Item</code> object, but it will
not be saved to the repository until <code>save</code> is called on it.</p>

<p>Before it can be saved, however, you must specify where in the Fedora node
hierarchy you want it to reside. You do that by setting its
<code>parent_url</code> property:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='label'>parent_url:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://url/of/parent/container</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_save!'>save!</span>
</code></pre>

<p>Or, if you are not sure of its parent&#39;s URL, but you have its parent:</p>

<pre class="code ruby"><code class="ruby">parent_item = Item.find(..)
new_item = Item.new(parent_url: parent_item.repository_url)
new_item.save!
</code></pre>

<p><code>Item.create</code> will create and save an object immediately.</p>

<p>Both of these methods accept a hash of properties as an argument.</p>

<p>Bang versions (!) of <code>create</code> and <code>save</code> are
available that will raise errors if anything goes wrong.</p>

<p>Note that the constructor accepts any parameter defined in a
<code>property</code> statement, as well as any <code>belongs_to</code>
relationship.</p>

<h3 id="label-Establishing+Relationships">Establishing Relationships</h3>

<p>Establishing relationships between two new entities is easy:</p>

<pre class="code ruby"><code class="ruby">collection = Collection.new(..)
collection.save!
item = Item.new(collection: collection)
item.save!
</code></pre>

<p>As of the current version, relationships must be set on the owned side, so
doing something like <code>collection.items &lt;&lt; item</code> is not
possible. Also, notice that we had to save both entities separately.
ActiveMedusa doesn&#39;t cascade these.</p>

<h3 id="label-Requesting+a+Slug+-F0-9F-90-8C">Requesting a Slug üêå</h3>

<p>You can request that your new entity be given a particular URL slug in the
repository before you save it:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_requested_slug'>requested_slug</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some-other-item</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_save!'>save!</span>
</code></pre>

<p>There is no guarantee, however, that the entity will actually receive this
slug, and no error will be raised if it doesn&#39;t.</p>

<p>For reasons related to Fedora performance, slugs are not advised.</p>

<h2 id="label-Updating+Entities">Updating Entities</h2>

<p>Call <code>update</code> on an entity. (Bang version [!] also available.)
This method accepts a parameter list into which you can pass any updated
<code>property</code> value:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_update'>update</span><span class='lparen'>(</span><span class='label'>some_property:</span> <span class='int'>55</span><span class='rparen'>)</span>
</code></pre>

<h2 id="label-Deleting+Entities">Deleting Entities</h2>

<p>Call <code>delete</code> on an entity. This method accepts an optional
boolean parameter that will delete its tombstone as well.</p>

<h2 id="label-Loading+Entities">Loading Entities</h2>

<p><em>Note: Newly created entities cannot be loaded until the Solr index has
been committed. ActiveMedusa will not commit it automatically.</em></p>

<p>To load an item by some property, you can use one of the finder methods,
like <code>find</code>, which will find by repository UUID:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_find'>find</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some UUID</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<p>If <code>find</code> finds multiple entities, it will return only one. This
is the only finder method that will raise an error if nothing is found.</p>

<p>Alternatively, you can find by repository URI:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_find_by_uri'>find_by_uri</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://localhost:8080/fcrepo/rest/kumquats</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<p>Then, there are the <code>find_by_x</code> methods, where <code>x</code>
corresponds to some <code>property</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_find_by_title'>find_by_title</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>2003 Global Outlook for 6-Quart Slow-Cookers</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<p>Once an entity has been loaded, it can be reloaded:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_reload!'>reload!</span>
</code></pre>

<h3 id="label-Loading+Entities+of+Unknown+Type">Loading Entities of Unknown Type</h3>

<p>Suppose you have an entity URI or UUID, but you are unsure of the class of
the entity it identifies ‚Äì you don&#39;t know whether it&#39;s an
<code>Item</code> or a <code>Collection</code>, and therefore don&#39;t
know which class <code>find</code> method to use. In that case, you can
call <code>find</code> on <code>ActiveMedusa::Container</code> to return an
instance of the correct class:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item_or_collection'>item_or_collection</span> <span class='op'>=</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span><span class='period'>.</span><span class='id identifier rubyid_find'>find</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>...</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<h3 id="label-Reading+-26+Writing+Metadata">Reading &amp; Writing Metadata</h3>

<p>The item&#39;s complete RDF graph is available by calling
<code>rdf_graph</code> on any entity instance. This returns an
<code>RDF::Graph</code> instance which you can read:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_rdf_graph'>rdf_graph</span><span class='period'>.</span><span class='id identifier rubyid_each_statement'>each_statement</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_st'>st</span><span class='op'>|</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_st'>st</span><span class='period'>.</span><span class='id identifier rubyid_predicate'>predicate</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://purl.org/dc/elements/1.1/title</span><span class='tstring_end'>&#39;</span></span>
    <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Title is: </span><span class='tstring_end'>&#39;</span></span> <span class='op'>+</span> <span class='id identifier rubyid_st'>st</span><span class='period'>.</span><span class='id identifier rubyid_object'>object</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>As well as write to:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_rdf_graph'>rdf_graph</span> <span class='op'>&lt;&lt;</span> <span class='lbracket'>[</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='const'>RDF</span><span class='op'>::</span><span class='const'>URI</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://purl.org/dc/elements/1.1/title</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Epistemology of the Kumquat</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span>
</code></pre>

<p>You would then need to call <code>item.save</code> to persist this change.</p>

<h3 id="label-Other+Useful+Entity+Methods">Other Useful Entity Methods</h3>
<ul><li>
<p><code>id</code>/<code>uuid</code> (returns the node&#39;s UUID)</p>
</li><li>
<p><code>created_at</code> (returns the RDF object of
<code>fedora:created</code> as a <code>Time</code> object)</p>
</li><li>
<p><code>updated_at</code> (returns the RDF object of
<code>fedora:lastModified</code> as a <code>Time</code>  object)</p>
</li><li>
<p><code>repository_url</code> (returns the node&#39;s repository URI/URL)</p>
</li><li>
<p><code>destroyed?</code></p>
</li><li>
<p><code>persisted?</code></p>
</li></ul>

<h2 id="label-Node+Hierarchy+Traversal">Node Hierarchy Traversal</h2>

<p>The <code>children</code> method will enable you to enumerate a
container&#39;s LDP children:</p>

<pre class="code ruby"><code class="ruby">collection = Collection.find(&#39;..&#39;)
collection.children.each { |child| .. }
</code></pre>

<p>Likewise, a child can get its parent:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_parent'>parent</span> <span class='op'>=</span> <span class='id identifier rubyid_child'>child</span><span class='period'>.</span><span class='id identifier rubyid_parent'>parent</span>
</code></pre>

<p>Note that these will only work for parent or child containers that have a
class triple; see <code>entity_class_uri</code> above.</p>

<h2 id="label-Binary+Entities">Binary Entities</h2>

<p>Binary entities work similarly to container entities. Using the example
above, a <code>Bytestream</code> can be initialized like an
<code>Item</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_b'>b</span> <span class='op'>=</span> <span class='const'>Bytestream</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='label'>parent_url:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://url/of/parent/container</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<p>But before it can be saved, you will want to associate some data with it.
You can specify a file to upload:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_b'>b</span><span class='period'>.</span><span class='id identifier rubyid_upload_pathname'>upload_pathname</span> <span class='op'>=</span> <span class='const'>File</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>path</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>to</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>file.tif</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<p>Or, you can specify an external URL:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_b'>b</span><span class='period'>.</span><span class='id identifier rubyid_external_resource_url'>external_resource_url</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>Optionally, but ideally, you should also specify the binary&#39;s media
type:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_b'>b</span><span class='period'>.</span><span class='id identifier rubyid_media_type'>media_type</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>image/tiff</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>At this point, it can be saved just like a container:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_b'>b</span><span class='period'>.</span><span class='id identifier rubyid_save!'>save!</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_b'>b</span><span class='period'>.</span><span class='id identifier rubyid_repository_url'>repository_url</span> <span class='comment'># binary content now available here
</span></code></pre>

<p>Once the binary content has been saved, it cannot be changed. In Fedora,
binary nodes have supplementary metadata available at the
<code>/fcr:metadata</code> path under their URL. This is the only thing
that will be updated when you call <code>save</code> on an already-saved
binary resource, A binary entity&#39;s RDF graph is available via its
<code>rdf_graph</code> accessor, just like a container.</p>

<h3 id="label-Accessing+Binary+Nodes">Accessing Binary Nodes</h3>

<p>Binary nodes are not indexed in Solr. If you want to be able to retrieve
them later via ActiveMedusa, you need to make sure they are accessible via
a relationship with some other entity. In the example above,
<code>Item</code> has a one-to-many relationship with
<code>Bytestream</code>, which makes its bytestreams accessible via the
<code>bytestreams</code> accessor:</p>

<pre class="code ruby"><code class="ruby">item = Item.find(&#39;..&#39;)
item.bytestreams.each { |b| .. }
</code></pre>

<h2 id="label-Searching+For+Entities">Searching For Entities</h2>

<p><em>Note 1: Newly added entities will not appear in search results until
the Solr index has been committed. ActiveMedusa will not commit it
automatically.</em></p>

<p><em>Note 2: If you are using fcrepo-message-consumer or fcrepo-camel, newly
created entities will not appear in search results in the same thread
unless enough time has elapsed between creation and query for Solr to have
received them, which will rarely be the case. An ugly way of getting around
this is to <code>sleep</code> for a bit after saving an entity to wait for
Solr to catch up - hoping that it does in time. This is a crude workaround
for a fundamental ‚Äúgotcha‚Äù of this kind of asynchronous messaging
architecture.</em></p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='label'>some_property:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>cats</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>arbitrary Solr condition</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_filter'>filter</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>arbitrary Solr filter query</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<p><code>where</code> corresponds to a Solr <code>q</code> parameter, and
<code>filter</code> corresponds to a <code>fq</code> parameter.</p>

<p>Items are loaded when <code>to_a</code> is called, either explicitly or
implicitly, such as by <code>each</code>.</p>

<h3 id="label-Ordering">Ordering</h3>

<p>By default, results are sorted by relevance (score). To override this, use
<code>order</code> to sort by any sortable Solr field:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_order'>order</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some_solr_field</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='symbol'>:asc</span><span class='rparen'>)</span>
<span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_order'>order</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some_solr_field</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'># same effect as above
</span><span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_order'>order</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some_solr_field</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='symbol'>:desc</span><span class='rparen'>)</span>
<span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_order'>order</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some_solr_field desc</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<h3 id="label-Counts">Counts</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_items'>items</span><span class='period'>.</span><span class='id identifier rubyid_count'>count</span> <span class='comment'># shortcut for items.to_a.total_length
</span></code></pre>

<h3 id="label-Start-2FLimit">Start/Limit</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_items'>items</span><span class='period'>.</span><span class='id identifier rubyid_start'>start</span><span class='lparen'>(</span><span class='int'>20</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_limit'>limit</span><span class='lparen'>(</span><span class='int'>20</span><span class='rparen'>)</span>
</code></pre>

<h3 id="label-Faceting">Faceting</h3>

<p>You can add facet queries:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_facet'>facet</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>creator:Napoleon%20Bonaparte</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
<span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_facet'>facet</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>type:Book</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>subject:Citrus</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span><span class='rparen'>)</span>
</code></pre>

<p>To access returned facets, you might do something like:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>..</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
<span class='comment'># facet_fields returns an array of ActiveMedusa::Facet objects.
</span><span class='id identifier rubyid_items'>items</span><span class='period'>.</span><span class='id identifier rubyid_facet_fields'>facet_fields</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_facet'>facet</span><span class='op'>|</span>
  <span class='comment'># A Facet may have one or more ActiveMedusa::Facet::Term objects.
</span>  <span class='id identifier rubyid_facet'>facet</span><span class='period'>.</span><span class='id identifier rubyid_terms'>terms</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_term'>term</span><span class='op'>|</span>
    <span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_term'>term</span><span class='period'>.</span><span class='id identifier rubyid_count'>count</span>
    <span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_term'>term</span><span class='period'>.</span><span class='id identifier rubyid_label'>label</span>
    <span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_term'>term</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Faceting is enabled by default. To improve performance, you can turn it off
if you aren&#39;t using it:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>...</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_facet'>facet</span><span class='lparen'>(</span><span class='kw'>false</span><span class='rparen'>)</span>
</code></pre>

<h3 id="label-Relevance">Relevance</h3>

<p>If no sort order is provided (via <code>order</code>), results will be
sorted by relevance. A relevance score can be accessed via the transient
<code>score</code> property of any retrieved entity.</p>

<h3 id="label-22More+Like+This-22">‚ÄúMore Like This‚Äù</h3>

<p>If you have the <a
href="https://wiki.apache.org/solr/MoreLikeThisHandler">MoreLikeThisHandler</a>
enabled in your <code>solrconfig.xml</code>, you can query by similarity:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_find'>find</span><span class='lparen'>(</span><span class='id identifier rubyid_id'>id</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_more_like_this'>more_like_this</span><span class='period'>.</span><span class='id identifier rubyid_limit'>limit</span><span class='lparen'>(</span><span class='int'>5</span><span class='rparen'>)</span>
</code></pre>

<h2 id="label-Transactions">Transactions</h2>

<p>Simply wrap any CRUD operation(s) inside a block:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Base</span><span class='period'>.</span><span class='id identifier rubyid_transaction'>transaction</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_tx_url'>tx_url</span><span class='op'>|</span>
  <span class='comment'># Any code present here will occur within a transaction.
</span>  <span class='comment'># Raising an error will roll back the transaction.
</span>  <span class='comment'># Otherwise, it will commit automatically when the block ends.
</span><span class='kw'>end</span>
</code></pre>

<p>Note: it is not possible to query within a transaction. (Fedora does not
dispatch messages about operations that happen inside transactions until
they have been committed.)</p>

<h2 id="label-Validation">Validation</h2>

<p><code>ActiveMedusa::Base</code> includes <code>ActiveModel::Model</code>,
which supplies all the validation functionality that ActiveRecord enjoys.
So, you can use ActiveRecord validation methods on your ActiveMedusa
entities.</p>

<p>Note that validation failures will raise an
<code>ActiveMedusa::RecordInvalid</code> instead of an
<code>ActiveRecord::RecordInvalid</code>.</p>

<h2 id="label-Forms">Forms</h2>

<p>Because <code>ActiveMedusa::Base</code> includes
<code>ActiveModel::Model</code>, your ActiveMedusa entities should work
perfectly well with Rails&#39; FormHelper. (Other form frameworks are
untested.)</p>

<h2 id="label-Callbacks">Callbacks</h2>

<p>Your entities can use the following <code>ActiveModel::Model</code>
callbacks:</p>
<ul><li>
<p><code>before_create</code></p>
</li><li>
<p><code>before_destroy</code></p>
</li><li>
<p><code>before_load</code></p>
</li><li>
<p><code>before_save</code></p>
</li><li>
<p><code>before_update</code></p>
</li><li>
<p><code>after_create</code></p>
</li><li>
<p><code>after_destroy</code></p>
</li><li>
<p><code>after_load</code></p>
</li><li>
<p><code>after_save</code></p>
</li><li>
<p><code>after_update</code></p>
</li></ul>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Item</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span>
  <span class='id identifier rubyid_before_save'>before_save</span> <span class='symbol'>:do_something</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_do_something'>do_something</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h1 id="label-Development">Development</h1>

<p>After checking out the repo, run <code>bin/setup</code> to install
dependencies. Then, run <code>bin/console</code> for an interactive prompt
that will allow you to experiment.</p>

<p>To install this gem onto your local machine, run <code>bundle exec rake
install</code>. To release a new version, update the version number in
<code>version.rb</code>, and then run <code>bundle exec rake release</code>
to create a git tag for the version, push git commits and tags, and push
the <code>.gem</code> file to <a
href="https://rubygems.org">rubygems.org</a>.</p>

<h2 id="label-Debugging">Debugging</h2>

<p><code>ActiveMedusa::Relation</code> has a <code>solr_response</code> method
that you can use to inspect the query and see the raw Solr results. Use it
like this:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_to_a'>to_a</span> <span class='comment'># to_a executes the Solr request
</span><span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_items'>items</span><span class='period'>.</span><span class='id identifier rubyid_solr_response'>solr_response</span><span class='period'>.</span><span class='id identifier rubyid_inspect'>inspect</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_items'>items</span><span class='period'>.</span><span class='id identifier rubyid_solr_response'>solr_response</span><span class='period'>.</span><span class='id identifier rubyid_request'>request</span><span class='period'>.</span><span class='id identifier rubyid_inspect'>inspect</span>
</code></pre>

<p>Note that <code>solr_response</code> will return <code>nil</code> until a
request has been executed.</p>

<h1 id="label-Contributing">Contributing</h1>
<ol><li>
<p>Fork it (<a
href="https://github.com/[my-github-username]/active-medusa/fork">github.com/[my-github-username]/active-medusa/fork</a>)</p>
</li><li>
<p>Create your feature branch (<code>git checkout -b my-new-feature</code>)</p>
</li><li>
<p>Commit your changes (<code>git commit -am &#39;Add some
feature&#39;</code>)</p>
</li><li>
<p>Push to the branch (<code>git push origin my-new-feature</code>)</p>
</li><li>
<p>Create a new Pull Request</p>
</li></ol>
</div></div>

    <div id="footer">
  Generated on Tue Jul 14 11:35:37 2015 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.6 (ruby-2.1.1).
</div>

  </body>
</html>