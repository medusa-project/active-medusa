<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>
  File: README
  
    &mdash; ActiveMedusa
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!file.README.html";
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'>
<h1 id="label-ActiveMedusa">ActiveMedusa</h1>

<p>ActiveMedusa provides an ActiveRecord-style interface to a Fedora 4
repository, using Solr for lookup and querying.</p>
<ul><li>
<p><strong><a href="https://github.com/medusa-project/active-medusa">GitHub
home</a></strong></p>
</li><li>
<p><strong><a
href="http://medusa-project.github.io/active-medusa/frames.html">API
documentation</a></strong></p>
</li></ul>

<h1 id="label-Features">Features</h1>
<ul><li>
<p>ActiveRecord-like syntax for CRUD and querying.</p>
</li><li>
<p>Basic and somewhat customizable RDF ontology. Create your own RDF
predicates  or use existing ones.</p>
</li><li>
<p>Customizable Solr schema. Although some extra fields are required, their 
names are up to you.</p>
</li><li>
<p>Can work with different Solr indexing strategies, including self-indexing
and  fcrepo-message-consumer/fcrepo-camel.</p>
</li><li>
<p>Supports binary and container nodes, both of which are first-class,
queryable  entities.</p>
</li><li>
<p>Supports Fedora transactions.</p>
</li><li>
<p>Direct read/write access to entities&#39; source RDF graphs.</p>
</li><li>
<p>Supports “belongs-to” and “has-many” relationships between entities.</p>
</li><li>
<p>No-configuration support for node hierarchy traversal via automatic
<code>parent</code>  and <code>children</code> methods on entities.</p>
</li></ul>

<h1 id="label-Limitations">Limitations</h1>
<ul><li>
<p>No cascading</p>
</li><li>
<p>No uniquing</p>
</li><li>
<p>Can only set references on the owned side</p>
</li><li>
<p>Missing support for some Fedora features like moving nodes, versioning,
etc.</p>
</li><li>
<p>Probably a lot more</p>
</li></ul>

<h1 id="label-Requirements">Requirements</h1>
<ul><li>
<p>Ruby 2.x</p>
</li><li>
<p>Fedora 4.1.1 or greater</p>
</li></ul>

<h1 id="label-Installation">Installation</h1>

<p><em>Note: If you are already using ActiveMedusa, skip to Upgrading
below.</em></p>

<p>Currently ActiveMedusa is not available via rubygems. There are a couple of
other options:</p>

<h2 id="label-Refer+to+a+local+copy">Refer to a local copy</h2>

<p>Check out the code from GitHub and point to it in your application&#39;s
Gemfile:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>path:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>/path/to/active_medusa</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<h2 id="label-Refer+to+a+copy+on+GitHub">Refer to a copy on GitHub</h2>

<p>Add one of these lines to your application&#39;s Gemfile, depending on what
you&#39;d like to work with:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># bleeding-edge
</span><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>github:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>medusa-project/active-medusa</span><span class='tstring_end'>&#39;</span></span>
<span class='comment'># the latest release
</span><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>github:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>medusa-project/active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>branch:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>master</span><span class='tstring_end'>&#39;</span></span>
<span class='comment'># a particular release
</span><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>github:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>medusa-project/active-medusa</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>tag:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>1.0.0</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>Then execute:</p>

<pre class="code ruby"><code class="ruby">$ bundle</code></pre>

<h1 id="label-Upgrading">Upgrading</h1>

<h2 id="label-1.0.0+to+1.1.0">1.0.0 to 1.1.0</h2>
<ol><li>
<p>Add <code>config.solr_parent_uri_field</code> to your
<code>ActiveMedusa::Configuration</code>  initializer.</p>
</li><li>
<p>Decide whether you want to use the new <code>ActiveMedusa::Indexable</code>
module  (see below).</p>
</li></ol>

<h2 id="label-1.1.0+to+2.0.0">1.1.0 to 2.0.0</h2>
<ol><li>
<p>Remove <code>config.solr_uuid_field</code> from your
<code>ActiveMedusa::Configuration</code>  initializer.</p>
</li><li>
<p>Rename <code>config.solr_uri_field</code> to <code>solr_id_field</code> in
your  <code>ActiveMedusa::Configuration</code> initializer.</p>
</li><li>
<p>Remove any calls to <code>ActiveMedusa::Querying.find_by_uuid</code>.</p>
</li><li>
<p>Remove any calls to <code>ActiveMedusa::Base.uuid</code>.</p>
</li><li>
<p>Take into account that <code>ActiveMedusa::Querying.find</code> now finds
by repository  node URI instead of UUID.</p>
</li><li>
<p>Be aware that <code>ActiveMedusa::Base.repository_url</code> is now an
alias of  <code>id</code>.</p>
</li><li>
<p>Replace any handling of <code>HTTPClient::BadResponseError</code> with
handling of  <code>ActiveMedusa::RepositoryError</code>.</p>
</li><li>
<p>Reindex.</p>
</li></ol>

<h1 id="label-Usage">Usage</h1>

<h2 id="label-Initializing">Initializing</h2>

<p>ActiveMedusa needs to know some stuff about your setup. You can tell it
like this. Documentation of each option is available <a
href="http://medusa-project.github.io/active-medusa/ActiveMedusa/Configuration.html">here</a>.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Configuration</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_config'>config</span><span class='op'>|</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_fedora_url'>fedora_url</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://localhost:8080/fcrepo/rest</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_logger'>logger</span> <span class='op'>=</span> <span class='const'>Rails</span><span class='period'>.</span><span class='id identifier rubyid_logger'>logger</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_class_predicate'>class_predicate</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://www.w3.org/2000/01/rdf-schema#Class</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_url'>solr_url</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://localhost:8983/solr</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_core'>solr_core</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>collection1</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_more_like_this_endpoint'>solr_more_like_this_endpoint</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>/mlt</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_class_field'>solr_class_field</span> <span class='op'>=</span> <span class='symbol'>:class_s</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_id_field'>solr_id_field</span> <span class='op'>=</span> <span class='symbol'>:id</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_parent_uri_field'>solr_parent_uri_field</span> <span class='op'>=</span> <span class='symbol'>:parent_uri_s</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_default_search_field'>solr_default_search_field</span> <span class='op'>=</span> <span class='symbol'>:searchall_txt</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_default_facetable_fields'>solr_default_facetable_fields</span> <span class='op'>=</span> <span class='lbracket'>[</span>
      <span class='symbol'>:collection_facet</span><span class='comma'>,</span> <span class='symbol'>:creator_facet</span><span class='comma'>,</span> <span class='symbol'>:date_facet</span><span class='comma'>,</span> <span class='symbol'>:format_facet</span><span class='comma'>,</span>
      <span class='symbol'>:language_facet</span><span class='rbracket'>]</span>
<span class='kw'>end</span>
</code></pre>

<p>(If you are using Rails, you would put this in
<code>config/initializers/active_medusa.rb</code>, and then restart your
application.)</p>

<h2 id="label-Defining+Entities">Defining Entities</h2>

<p>Here we will declare some entity/model classes that will be used throughout
this readme. <code>Collection</code> and <code>Item</code> will correspond
to Fedora container nodes, and <code>Bytestream</code> will correspond to
Fedora binary nodes. These are all common entities found in many
repositories, but you could change the nomenclature, or add other entities.
Note that <code>Collection</code> and <code>Item</code> inherit from
<code>ActiveMedusa::Container</code> while <code>Bytestream</code> inherits
from <code>ActiveMedusa::Binary</code>. These are the two base classes from
which all of your entities must inherit.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># collection.rb
</span><span class='kw'>class</span> <span class='const'>Collection</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span>
  <span class='id identifier rubyid_entity_class_uri'>entity_class_uri</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://pcdm.org/models#Collection</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbol'>:items</span>
  <span class='id identifier rubyid_property'>property</span> <span class='symbol'>:title</span><span class='comma'>,</span>
           <span class='label'>type:</span> <span class='symbol'>:string</span><span class='comma'>,</span>
           <span class='label'>rdf_predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://purl.org/dc/elements/1.1/title</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
           <span class='label'>solr_field:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>title_s</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>

<span class='comment'># item.rb
</span><span class='kw'>class</span> <span class='const'>Item</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span>
  <span class='id identifier rubyid_entity_class_uri'>entity_class_uri</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://pcdm.org/models#Object</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbol'>:items</span>
  <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbol'>:bytestreams</span>
  <span class='id identifier rubyid_belongs_to'>belongs_to</span> <span class='symbol'>:collection</span><span class='comma'>,</span> <span class='label'>rdf_predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/isMemberOf</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
             <span class='label'>solr_field:</span> <span class='symbol'>:collection_s</span>
  <span class='id identifier rubyid_belongs_to'>belongs_to</span> <span class='symbol'>:item</span><span class='comma'>,</span> <span class='label'>rdf_predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/isChildOf</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
             <span class='label'>solr_field:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>parent_s</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='label'>name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>parent</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_property'>property</span> <span class='symbol'>:full_text</span><span class='comma'>,</span>
           <span class='label'>type:</span> <span class='symbol'>:string</span><span class='comma'>,</span>
           <span class='label'>rdf_predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/fullText</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
           <span class='label'>solr_field:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>full_text_txt</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>

<span class='comment'># bytestream.rb
</span><span class='kw'>class</span> <span class='const'>Bytestream</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Binary</span>
  <span class='id identifier rubyid_entity_class_uri'>entity_class_uri</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://pcdm.org/models#File</span><span class='tstring_end'>&#39;</span></span>
  <span class='id identifier rubyid_belongs_to'>belongs_to</span> <span class='symbol'>:item</span><span class='comma'>,</span> <span class='label'>rdf_predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/isOwnedBy</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>
</code></pre>

<h3 id="label-Defining+Classes">Defining Classes</h3>

<p>Every entity needs to have a URI designating its class. This can be
specified with the <code>entity_class_uri</code> method. The value you
define will be used as the object of a triple whose predicate is the value
of <code>ActiveMedusa::Configuration.class_predicate</code>.</p>

<h3 id="label-Defining+Properties">Defining Properties</h3>

<p><code>property</code> is a convenience method that maps entity properties
to an instance&#39;s RDF graph and creates accessor and finder methods for
them. It also enables bonus features like validation,
<code>find_by_x</code>, auto-generated accessors, and ability to use the
properties in <code>create</code> and <code>update</code> calls.</p>

<p><code>property</code> predicates must be unique and can only be used in one
triple per entity graph.</p>

<p>You do not need to define all, or any, of an entity&#39;s properties with
<code>property</code>. If you prefer, you can manually mutate an
instance&#39;s <code>RDF::Graph</code> instance, accessible via
<code>rdf_graph</code>. But in that case, you wouldn&#39;t get the bonus
features.</p>

<h3 id="label-Defining+Relationships">Defining Relationships</h3>

<p>Using the <code>has_many</code> and <code>belongs_to</code> methods, the
example above specifies that collections can contain zero or more items;
items can contain zero or more bytestreams; and items can also contain zero
or more items (as in aggregations, a.k.a. compound objects). Note that both
sides of the relationship must be specified, so for every
<code>has_many</code> on an owning entity, there must be a
<code>belongs_to</code> on the owned entity. The <code>belongs_to</code>
side also requires a <code>:predicate</code> option that specifies what RDF
predicate to use to store the relationship in Fedora.</p>

<p><em>Note: If any of your entity classes reside in a namespace, you will
need to add a <code>class_name</code> option to your relationship
definitions:</em></p>

<pre class="code ruby"><code class="ruby"><span class='comment'># collection.rb
</span><span class='kw'>module</span> <span class='const'>Entities</span>
  <span class='kw'>class</span> <span class='const'>Collection</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span>
    <span class='id identifier rubyid_has_many'>has_many</span> <span class='symbol'>:items</span><span class='comma'>,</span> <span class='label'>class_name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Entities::Item</span><span class='tstring_end'>&#39;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='comment'># item.rb
</span><span class='kw'>module</span> <span class='const'>Entities</span>
  <span class='kw'>class</span> <span class='const'>Item</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span>
    <span class='id identifier rubyid_belongs_to'>belongs_to</span> <span class='symbol'>:collection</span><span class='comma'>,</span> <span class='label'>predicate:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/isMemberOf</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
               <span class='label'>solr_field:</span> <span class='symbol'>:collection_s</span><span class='comma'>,</span> <span class='label'>class_name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Entities::Collection</span><span class='tstring_end'>&#39;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h2 id="label-Configuring+a+Solr+update+strategy">Configuring a Solr update strategy</h2>

<p>By default, ActiveMedusa does not write to Solr, yet it is going to expect
that something will. You have a couple of options for dealing with this.
One would be to use a strategy like <a
href="https://github.com/fcrepo4/fcrepo-message-consumer">fcrepo-message-consumer</a>
(deprecated) or <a
href="https://github.com/fcrepo4/fcrepo-camel">fcrepo-camel</a> which keep
Solr updated by listening for changes in your repository. Another would be
to populate Solr from your application.</p>

<p>See one of the next sections for info on getting this working.</p>

<h3 id="label-Updating+Solr+from+your+application">Updating Solr from your application</h3>

<p>ActiveMedusa provides an optional helper module, <code>Indexable</code>,
that will assist you in keeping Solr updated yourself. To use it, include
it in any entity class:</p>

<pre class="code ruby"><code class="ruby"># item.rb
class Item &lt; ActiveMedusa::Container
  include ActiveMedusa::Indexable
  ...
end
</code></pre>

<p><code>Item</code> instances will now be created, updated, and deleted in
Solr automatically.</p>

<p>See the <a
href="http://medusa-project.github.io/active-medusa/ActiveMedusa/Indexable.html">documentation
for Indexable</a> if you wish to change the way your entities get indexed.</p>

<h4 id="label-Handling+cascading+deletes">Handling cascading deletes</h4>

<p>When a node is deleted in Fedora, all of its children are deleted along
with it. Currently, <code>Indexable</code> does <strong>not</strong>
account for this. To deal with this properly, code would need to be added
to ActiveMedusa to delete the entire subtree of the deleted node
node-by-node from deepest to shallowest, which could be very slow,
depending on the size of the tree. There is an <a
href="https://github.com/medusa-project/active-medusa/issues/8">issue for
this in GitHub</a>.</p>

<h3 id="label-Updating+Solr+with+fcrepo-camel">Updating Solr with fcrepo-camel</h3>

<p>For this, you will need to get fcrepo-camel working, which is covered <a
href="https://wiki.duraspace.org/display/FEDORA4x/Setup+Camel+Message+Integrations">here</a>
and is beyond the scope of this readme. You might use an <a
href="https://wiki.duraspace.org/display/FEDORA4x/Indexing+Transformations">indexing
transformation</a> with it, or you might write custom code to respond to
Fedora change messages. Either way, you will need to account for all of the
same fields as <code>ActiveMedusa::Indexable.solr_document</code> does;
take a look at its implementation for details.</p>

<p><em>Note: with this strategy, do <strong>not</strong> add <code>include
ActiveMedusa::Indexable</code> to your entities.</em></p>

<p>The <a
href="https://wiki.duraspace.org/display/FEDORA4x/External+Search">Fedora
wiki</a> shows indexable nodes receiving
<code>indexing:hasIndexingTransformation</code> and <code>rdf:type</code>
triples. If you want to use these the way it prescribes, you will have to
add them to your entities manually – like this, for example:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Item</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span>
  <span class='id identifier rubyid_before_create'>before_create</span> <span class='symbol'>:add_indexing_triples</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_add_indexing_triples'>add_indexing_triples</span>
    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_rdf_graph'>rdf_graph</span> <span class='op'>&lt;&lt;</span> <span class='lbracket'>[</span><span class='const'>RDF</span><span class='op'>::</span><span class='const'>URI</span><span class='lparen'>(</span><span class='rparen'>)</span><span class='comma'>,</span>
        <span class='const'>RDF</span><span class='op'>::</span><span class='const'>URI</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://fedora.info/definitions/v4/indexing#hasIndexingTransformation</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='comma'>,</span>
        <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>default</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span>
    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_rdf_graph'>rdf_graph</span> <span class='op'>&lt;&lt;</span> <span class='lbracket'>[</span><span class='const'>RDF</span><span class='op'>::</span><span class='const'>URI</span><span class='lparen'>(</span><span class='rparen'>)</span><span class='comma'>,</span>
        <span class='const'>RDF</span><span class='op'>::</span><span class='const'>URI</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://www.w3.org/1999/02/22-rdf-syntax-ns#type</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='comma'>,</span>
        <span class='const'>RDF</span><span class='op'>::</span><span class='const'>URI</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://fedora.info/definitions/v4/indexing#Indexable</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='rbracket'>]</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h2 id="label-Creating+Entities">Creating Entities</h2>

<p><code>Item.new</code> will create an <code>Item</code> object, but it will
not be saved to the repository until <code>save</code> is called on it.</p>

<p>Before it can be saved, however, you must specify where in the Fedora node
hierarchy you want it to reside. This is done by setting its
<code>parent_url</code> property:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='label'>parent_url:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://url/of/parent/container</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_save!'>save!</span>
</code></pre>

<p>Or, if you are not sure of its parent&#39;s URL, but you have its parent:</p>

<pre class="code ruby"><code class="ruby">parent_item = Item.find(..)
new_item = Item.new(parent_url: parent_item.id)
new_item.save!
</code></pre>

<p><code>Item.create</code> will create and save an object immediately.</p>

<p>Both of these methods accept a hash of properties as an argument.</p>

<p>Bang versions (!) of <code>create</code> and <code>save</code> are
available that will raise errors if anything goes wrong.</p>

<p>Note that the constructor accepts any parameter defined in a
<code>property</code> statement, as well as any <code>belongs_to</code>
relationship.</p>

<h3 id="label-Establishing+Relationships">Establishing Relationships</h3>

<p>To establish relationships between two new entities:</p>

<pre class="code ruby"><code class="ruby">collection = Collection.new(..)
collection.save!
item = Item.new(collection: collection)
item.save!
</code></pre>

<p>Currently, relationships must be set on the owned side, so doing something
like <code>collection.items &lt;&lt; item</code> is not possible. Also,
notice that both entities had to be saved separately. ActiveMedusa
doesn&#39;t cascade saves.</p>

<h3 id="label-Requesting+a+Slug+-F0-9F-90-8C">Requesting a Slug 🐌</h3>

<p>You can request that your new entity be given a particular URL slug in the
repository before you save it:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_requested_slug'>requested_slug</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some-other-item</span><span class='tstring_end'>&#39;</span></span>
<span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_save!'>save!</span>
</code></pre>

<p>There is no guarantee, however, that the entity will actually receive this
slug, and no error will be raised if it doesn&#39;t.</p>

<p>For the sake of Fedora performance, slugs are not advised.</p>

<h2 id="label-Updating+Entities">Updating Entities</h2>

<p>Call <code>update</code> on an entity. (Bang version [!] also available.)
This method accepts a parameter list into which you can pass any updated
<code>property</code> value:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_update'>update</span><span class='lparen'>(</span><span class='label'>some_property:</span> <span class='int'>55</span><span class='rparen'>)</span>
</code></pre>

<h2 id="label-Deleting+Entities">Deleting Entities</h2>

<p>Call <code>delete</code> on an entity. This method accepts an optional
<code>also_tombstone:</code> boolean parameter that will delete its
tombstone as well.</p>

<p><em>Note: Entities will not be deleted from Solr until the Solr index has
been committed. ActiveMedusa will not commit it automatically.</em></p>

<h2 id="label-Loading+Entities">Loading Entities</h2>

<h3 id="label-By+Repository+URI">By Repository URI</h3>

<p>Since version 2.0.0, ActiveMedusa uses the node repository URI as the
entity ID:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_find'>find</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://localhost:8080/fcrepo/rest/kumquats</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<p>This is the only finder method that will raise an error if nothing is
found.</p>

<h3 id="label-By+Property">By Property</h3>

<p>When you use <code>property</code> statements in entity classes, a
<code>find_by_x</code> method is auto-generated for each. So, if you had a
property named <code>title</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_find_by_title'>find_by_title</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>2003 Global Outlook for 6-Quart Slow-Cookers</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<h3 id="label-Reloading">Reloading</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_reload!'>reload!</span>
</code></pre>

<h3 id="label-Loading+Entities+of+Unknown+Type">Loading Entities of Unknown Type</h3>

<p>Suppose you have an entity URI, but are unsure of the class of the entity
it identifies – you don&#39;t know whether it&#39;s an <code>Item</code> or
a <code>Collection</code>, and therefore don&#39;t know which class
<code>find</code> method to use. In that case, you can call
<code>load</code> on <code>ActiveMedusa::Base</code> to return an instance
of the correct class:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item_or_collection'>item_or_collection</span> <span class='op'>=</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Base</span><span class='period'>.</span><span class='id identifier rubyid_load'>load</span><span class='lparen'>(</span><span class='id identifier rubyid_uri'>uri</span><span class='rparen'>)</span>
</code></pre>

<h3 id="label-Reading+-26+Writing+Metadata">Reading &amp; Writing Metadata</h3>

<p>The item&#39;s underlying RDF graph is available by calling
<code>rdf_graph</code> on any entity instance. This returns an
<code>RDF::Graph</code> instance which you can read:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_rdf_graph'>rdf_graph</span><span class='period'>.</span><span class='id identifier rubyid_each_statement'>each_statement</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_st'>st</span><span class='op'>|</span>
  <span class='kw'>if</span> <span class='id identifier rubyid_st'>st</span><span class='period'>.</span><span class='id identifier rubyid_predicate'>predicate</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://purl.org/dc/elements/1.1/title</span><span class='tstring_end'>&#39;</span></span>
    <span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Title is: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_st'>st</span><span class='period'>.</span><span class='id identifier rubyid_object'>object</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>As well as write to:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_item'>item</span><span class='period'>.</span><span class='id identifier rubyid_rdf_graph'>rdf_graph</span> <span class='op'>&lt;&lt;</span> <span class='lbracket'>[</span><span class='const'>RDF</span><span class='op'>::</span><span class='const'>URI</span><span class='lparen'>(</span><span class='rparen'>)</span><span class='comma'>,</span>
    <span class='const'>RDF</span><span class='op'>::</span><span class='const'>URI</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://purl.org/dc/elements/1.1/title</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='comma'>,</span>
    <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Epistemology of the Kumquat</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span>
</code></pre>

<p>You would then need to call <code>item.save</code> to persist this change.</p>

<h2 id="label-Node+Hierarchy+Traversal">Node Hierarchy Traversal</h2>

<p>The <code>children</code> method will enable you to enumerate a
container&#39;s LDP children:</p>

<pre class="code ruby"><code class="ruby">collection = Collection.find(&#39;..&#39;)
collection.children.each { |child| .. }
</code></pre>

<p>Likewise, a child can get its parent:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_parent'>parent</span> <span class='op'>=</span> <span class='id identifier rubyid_child'>child</span><span class='period'>.</span><span class='id identifier rubyid_parent'>parent</span>
</code></pre>

<p>Note that these will only work for parent or child containers that have a
class triple; see <code>entity_class_uri</code> above.</p>

<h2 id="label-Binary+Entities">Binary Entities</h2>

<p>Binary entities work similarly to container entities. Using the example
above, a <code>Bytestream</code> can be initialized like an
<code>Item</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_b'>b</span> <span class='op'>=</span> <span class='const'>Bytestream</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='label'>parent_url:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://url/of/parent/container</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<p>Before saving this, you will probably want to associate some data with it.
You can specify an IO stream to read:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_b'>b</span><span class='period'>.</span><span class='id identifier rubyid_upload_io'>upload_io</span> <span class='op'>=</span> <span class='const'>File</span><span class='period'>.</span><span class='id identifier rubyid_read'>read</span><span class='lparen'>(</span><span class='const'>File</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>path</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>to</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>file.tif</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='rparen'>)</span>
</code></pre>

<p>Or, you can specify an external URL:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_b'>b</span><span class='period'>.</span><span class='id identifier rubyid_external_resource_url'>external_resource_url</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>http://example.org/</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>Optionally, but ideally, you should also specify the binary&#39;s media
type:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_b'>b</span><span class='period'>.</span><span class='id identifier rubyid_media_type'>media_type</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>image/tiff</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>If you want, you can override its filename (non-URLs only):</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_b'>b</span><span class='period'>.</span><span class='id identifier rubyid_upload_filename'>upload_filename</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>overridden.tif</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>At this point, it can be saved just like a container:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_b'>b</span><span class='period'>.</span><span class='id identifier rubyid_save!'>save!</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_b'>b</span><span class='period'>.</span><span class='id identifier rubyid_id'>id</span> <span class='comment'># binary node now available here
</span></code></pre>

<p>Once the binary content has been saved, it cannot be changed. In Fedora,
binary nodes have supplementary metadata available at the
<code>/fcr:metadata</code> path under their URL. This is the only thing
that will be updated when you call <code>save</code> on an already-saved
binary resource, A binary entity&#39;s RDF graph is available via its
<code>rdf_graph</code> accessor, just like a container.</p>

<h2 id="label-Searching+For+Entities">Searching For Entities</h2>

<p><em>Note 1: Newly added entities will not appear in search results until
the Solr index has been committed. ActiveMedusa will not commit it
automatically.</em></p>

<p><em>Note 2: If you are using fcrepo-message-consumer or fcrepo-camel, newly
created entities will not appear in search results in the same thread
unless enough time has elapsed between creation and query for Solr to have
received them, which will rarely be the case. An ugly way of getting around
this is to <code>sleep</code> for a bit after saving an entity to wait for
Solr to catch up - hoping that it does in time. This is a crude workaround
for a fundamental consequence of this kind of asynchronous messaging
architecture.</em></p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='label'>some_property:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>cats</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>arbitrary Solr condition</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='period'>.</span>
    <span class='id identifier rubyid_filter'>filter</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>arbitrary Solr filter query</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<p><code>where</code> corresponds to a Solr <code>q</code> parameter, and
<code>filter</code> corresponds to a <code>fq</code> parameter.</p>

<p>Items are loaded when <code>to_a</code> is called, either explicitly or
implicitly, such as by <code>each</code>.</p>

<h3 id="label-Ordering">Ordering</h3>

<p>By default, results are sorted by relevance (score). To override this, use
<code>order</code> to sort by any sortable Solr field:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_order'>order</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some_solr_field</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='symbol'>:asc</span><span class='rparen'>)</span>
<span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_order'>order</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some_solr_field</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'># same effect as above
</span><span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_order'>order</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some_solr_field</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=&gt;</span> <span class='symbol'>:desc</span><span class='rparen'>)</span>
<span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_order'>order</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>some_solr_field desc</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<h3 id="label-Counts">Counts</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_items'>items</span><span class='period'>.</span><span class='id identifier rubyid_count'>count</span> <span class='comment'># shortcut for items.to_a.total_length
</span></code></pre>

<h3 id="label-Start-2FLimit">Start/Limit</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_items'>items</span><span class='period'>.</span><span class='id identifier rubyid_start'>start</span><span class='lparen'>(</span><span class='int'>20</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_limit'>limit</span><span class='lparen'>(</span><span class='int'>20</span><span class='rparen'>)</span>
</code></pre>

<h3 id="label-Faceting">Faceting</h3>

<p>You can add facet queries:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_facet'>facet</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>creator:Napoleon%20Bonaparte</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
<span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_facet'>facet</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>type:Book</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>subject:Citrus</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span><span class='rparen'>)</span>
</code></pre>

<p>The default list of facetable fields is set in
<code>ActiveMedusa::Configuration.solr_default_facetable_fields</code>.
<code>ActiveMedusa::Relation</code>&#39;s initializer will pre-populate its
<code>facetable_fields</code> property with the contents of this array. But
this property can be re-set at runtime. So, if your Configuration object
were to contain:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Configuration</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_config'>config</span><span class='op'>|</span>
  <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_solr_default_facetable_fields'>solr_default_facetable_fields</span> <span class='op'>=</span> <span class='lbracket'>[</span>
      <span class='symbol'>:collection_facet</span><span class='comma'>,</span> <span class='symbol'>:creator_facet</span><span class='comma'>,</span> <span class='symbol'>:date_facet</span><span class='comma'>,</span> <span class='symbol'>:format_facet</span><span class='comma'>,</span>
      <span class='symbol'>:language_facet</span><span class='rbracket'>]</span>
<span class='kw'>end</span>
</code></pre>

<p>Then, say you wanted to return more than just these facets, just once:</p>

<pre class="code ruby"><code class="ruby">config = ActiveMedusa::Configuration.instance
fields = config.solr_default_facetable_fields + [:type_facet, :publisher_facet]
items = Item.where(...).facetable_fields(fields)
</code></pre>

<p>To access returned facets, you might do something like:</p>

<pre class="code ruby"><code class="ruby">items = Item.where(...)
# facet_fields returns an array of ActiveMedusa::Facet objects.
items.facet_fields.each do |facet|
  # A Facet may have one or more ActiveMedusa::Facet::Term objects.
  facet.terms.each do |term|
    puts term.count
    puts term.label
    puts term.name
  end
end
</code></pre>

<p>Faceting is enabled by default. To improve performance, you can turn it off
if you aren&#39;t using it:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_where'>where</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>...</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_facet'>facet</span><span class='lparen'>(</span><span class='kw'>false</span><span class='rparen'>)</span>
</code></pre>

<h3 id="label-Relevance">Relevance</h3>

<p>If no sort order is provided (via <code>order</code>), results will be
sorted by relevance. A relevance score can be accessed via the transient
<code>score</code> property of any retrieved entity.</p>

<h3 id="label-22More+Like+This-22">“More Like This”</h3>

<p>If you have the <a
href="https://wiki.apache.org/solr/MoreLikeThisHandler">MoreLikeThisHandler</a>
enabled in your <code>solrconfig.xml</code>, you can query by similarity:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_find'>find</span><span class='lparen'>(</span><span class='id identifier rubyid_id'>id</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_more_like_this'>more_like_this</span><span class='period'>.</span><span class='id identifier rubyid_limit'>limit</span><span class='lparen'>(</span><span class='int'>5</span><span class='rparen'>)</span>
</code></pre>

<h2 id="label-Transactions">Transactions</h2>

<p>The example below illustrates a transaction. Anything inside the block will
have access to the base URL of the transaction as <code>tx_url</code>. To
create, update, or delete an entity within the transaction, use
<code>create</code>, <code>update</code>, <code>delete</code>,
<code>save</code>, etc. as usual, but set the entity&#39;s
<code>transaction_url</code> attribute first:</p>

<pre class="code ruby"><code class="ruby">ActiveMedusa::Base.transaction do |tx_url|
  # Any code present here will occur within a transaction.
  # Raising an error will roll back the transaction.
  # Otherwise, it will commit automatically when the block ends.
  item = Item.find(..)
  item.transaction_url = tx_url
  item.update!(some_property: &#39;kumquats&#39;)
end
</code></pre>

<p><em>Note: if you are using fcrepo-camel, keep in mind that Fedora does not
dispatch messages about operations that happen inside transactions until
they have been committed, meaning you won&#39;t be able to query for
entities created within the same transaction.</em></p>

<p><em>Note: if you are using <code>ActiveMedusa::Indexable</code>, keep in
mind that rolling back a transaction will <strong>not</strong> roll back
any changes to Solr made from within the transaction.</em></p>

<h2 id="label-Validation">Validation</h2>

<p><code>ActiveMedusa::Base</code> includes <code>ActiveModel::Model</code>,
which supplies all the validation functionality that ActiveRecord enjoys.
So, you can use ActiveRecord validation methods on your ActiveMedusa
entities.</p>

<p>Note that validation failures will raise an
<code>ActiveMedusa::RecordInvalid</code> instead of an
<code>ActiveRecord::RecordInvalid</code>.</p>

<h2 id="label-Forms">Forms</h2>

<p>Because <code>ActiveMedusa::Base</code> includes
<code>ActiveModel::Model</code>, your ActiveMedusa entities should work
perfectly well with Rails&#39; FormHelper.</p>

<h2 id="label-Callbacks">Callbacks</h2>

<p>Your entities can use the following <code>ActiveModel::Model</code>
callbacks:</p>
<ul><li>
<p><code>before_create</code></p>
</li><li>
<p><code>before_destroy</code></p>
</li><li>
<p><code>before_load</code></p>
</li><li>
<p><code>before_save</code></p>
</li><li>
<p><code>before_update</code></p>
</li><li>
<p><code>before_validation</code></p>
</li><li>
<p><code>after_create</code></p>
</li><li>
<p><code>after_destroy</code></p>
</li><li>
<p><code>after_load</code></p>
</li><li>
<p><code>after_save</code></p>
</li><li>
<p><code>after_update</code></p>
</li><li>
<p><code>after_validation</code></p>
</li></ul>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>Item</span> <span class='op'>&lt;</span> <span class='const'>ActiveMedusa</span><span class='op'>::</span><span class='const'>Container</span>
  <span class='id identifier rubyid_before_save'>before_save</span> <span class='symbol'>:do_something</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_do_something'>do_something</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h1 id="label-Versioning">Versioning</h1>

<p>ActiveMedusa uses <a href="http://semver.org">semantic versioning</a>.</p>

<h1 id="label-Change+Log">Change Log</h1>

<h2 id="label-2.0.0">2.0.0</h2>
<ul><li>
<p>Added validation callbacks on <code>ActiveMedusa::Base</code>.</p>
</li><li>
<p>Removed <code>ActiveMedusa::Configuration.solr_uuid_field</code>.</p>
</li><li>
<p>Renamed <code>ActiveMedusa::Configuration.solr_uri_field</code> to
<code>solr_id_field</code>.</p>
</li><li>
<p>Made <code>ActiveMedusa::Querying.find_by_uri</code> an alias of
<code>find</code>.</p>
</li><li>
<p>Removed <code>ActiveMedusa::Querying.find_by_uuid</code>.</p>
</li><li>
<p>Removed <code>ActiveMedusa::Base.uuid</code>.</p>
</li><li>
<p>Made <code>ActiveMedusa::Base.repository_url</code> an alias of
<code>id</code>.</p>
</li><li>
<p><code>ActiveMedusa::RepositoryError</code> is raised wherever an 
<code>HTTPClient::BadResponseError</code> would have been leaked.</p>
</li><li>
<p>Added <code>ActiveMedusa::Binary.upload_io</code> and
<code>upload_filename</code>.</p>
</li><li>
<p>ActiveMedusa no longer has anything to do with UUIDs.</p>
</li><li>
<p>ActiveMedusa now works with Fedora 4.3.</p>
</li></ul>

<h2 id="label-1.1.0">1.1.0</h2>
<ul><li>
<p>Added optional automatic Solr indexing via
<code>ActiveMedusa::Indexable</code></p>
</li><li>
<p>Added <code>ActiveMedusa::Configuration.solr_parent_uri_field</code></p>
</li><li>
<p>Documentation improvements</p>
</li><li>
<p>Log to stdout by default</p>
</li></ul>

<h2 id="label-1.0.0">1.0.0</h2>
<ul><li>
<p>First release.</p>
</li></ul>

<h1 id="label-Development">Development</h1>

<p>After checking out the repo, run <code>bin/setup</code> to install
dependencies. Then, run <code>bin/console</code> for an interactive prompt
that will allow you to experiment.</p>

<p>To install this gem onto your local machine, run <code>bundle exec rake
install</code>. To release a new version, update the version number in
<code>version.rb</code>, and then run <code>bundle exec rake release</code>
to create a git tag for the version, push git commits and tags, and push
the <code>.gem</code> file to <a
href="https://rubygems.org">rubygems.org</a>.</p>

<h2 id="label-Debugging">Debugging</h2>

<p><code>ActiveMedusa::Relation</code> has a <code>solr_response</code> method
that you can use to inspect the query and see the raw Solr results. Use it
like this:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_items'>items</span> <span class='op'>=</span> <span class='const'>Item</span><span class='period'>.</span><span class='id identifier rubyid_all'>all</span><span class='period'>.</span><span class='id identifier rubyid_to_a'>to_a</span> <span class='comment'># to_a executes the Solr request
</span><span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_items'>items</span><span class='period'>.</span><span class='id identifier rubyid_solr_response'>solr_response</span><span class='period'>.</span><span class='id identifier rubyid_inspect'>inspect</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_items'>items</span><span class='period'>.</span><span class='id identifier rubyid_solr_response'>solr_response</span><span class='period'>.</span><span class='id identifier rubyid_request'>request</span><span class='period'>.</span><span class='id identifier rubyid_inspect'>inspect</span>
</code></pre>

<p>Note that <code>solr_response</code> will return <code>nil</code> until a
request has been executed.</p>

<h1 id="label-Contributing">Contributing</h1>
<ol><li>
<p>Fork it (<a
href="https://github.com/[my-github-username]/active-medusa/fork">github.com/[my-github-username]/active-medusa/fork</a>)</p>
</li><li>
<p>Create your feature branch (<code>git checkout -b my-new-feature</code>)</p>
</li><li>
<p>Commit your changes (<code>git commit -am &#39;Add some
feature&#39;</code>)</p>
</li><li>
<p>Push to the branch (<code>git push origin my-new-feature</code>)</p>
</li><li>
<p>Create a new Pull Request</p>
</li></ol>
</div></div>

    <div id="footer">
  Generated on Tue Aug 25 10:35:38 2015 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.6 (ruby-2.2.2).
</div>

  </body>
</html>